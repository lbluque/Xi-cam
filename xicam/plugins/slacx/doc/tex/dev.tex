\chapter{development}
\label{ch:dev}

This chapter covers the best practices 
for contributing to \verb|slacx| via git (section~\ref{sec:slacx_dev})
and instructions for developing operations
for use in the \verb|slacx| workflow engine (section~\ref{sec:op_dev}).
These instructions are intended for people
who are familiar with the \verb|slacx| development team
and have received an invitation to work in their private repository.
Public forking of the repository is not currently allowed.

\section{contributing to slacx}
\label{sec:slacx_dev}

The \verb|slacx| repository is currently private.
Request access by getting in touch with the \verb|slacx| developers
at \verb|slacx-developers@slac.stanford.edu|. 
If you are looking for a long term relationship,
you can send an email to join the slacx-developers listserv.
Send an email to 
\begin{lstlisting}
listserv@listserv.slac.stanford.edu
\end{lstlisting}
with no subject and the following text in the body: 
\begin{lstlisting}
SUB SLACX-DEVELOPERS
\end{lstlisting}
If you want to unsubscribe, use:
\begin{lstlisting}
UNSUB SLACX-DEVELOPERS
\end{lstlisting}
If you need to configure your list settings, see the ListServ manual at
\begin{lstlisting}
http://www.lsoft.com/manuals/16.0/htmlhelp/list%20subscribers/coverpage.html
\end{lstlisting}

Code development is currently following the ``shared repository model'',
meaning developers have write access to the main repository.
In this model, you must be careful with your edits.
In particular, \textbf{all coding should be done in feature branches}.
Never push changes directly to the \verb|master| branch,
and only push to the \verb|dev| branch if you are absolutely sure it's a good idea.
If bad commits happen, we will roll back the problematic changes 
and initiate the process outlined below for pulling the new feature into \verb|dev|.

The \verb|master| branch is intended to be the most stable tested version,
and the \verb|dev| branch is for staging features that have been developed.
The rest of the branches should contain features being actively developed.
Once you have access, clone the repository
and create your own development or feature branch.
When you are satisfied, make sure your feature branch 
includes the latest changes to \verb|dev|
and either merge your feature into \verb|dev|,
or (if you're not fully comfortable with that),
submit a pull request to review the merging of your feature with \verb|dev|.
Below are are step-by-step instructions
for the command line and \verb|PyCharm| interfaces.

If you are developing a feature that belongs in the \verb|master| branch,
for example if it is a stability or infrastructure or documentation fix,
please always finish with a pull request.
 \newline

\textbf{--- start here the first time you work on slacx ---} 
\begin{enumerate} 
    \item Get in touch with the slacx developers to get access to the repository. 
        See ~\ref{sec:introduction}.
    \item Clone the repository: 
    \begin{itemize} 
        \item CL: \verb|git clone <REPO-URL>|. 
        \item \verb|PyCharm|: VCS > Checkout from Version Control > enter repository URL
    \end{itemize} 
    This copies the remote repository (hosted online)
    to a local directory (on your machine). 
    Your new directory contains the source code
    and a local \verb|master| branch 
    that tracks the remote \verb|master| branch.
    \item Create a \verb|dev| branch that tracks the origin's \verb|dev| branch.
    \begin{itemize} 
        \item CL: \verb|git checkout -b dev origin/dev|. 
        %\verb|git checkout dev|, 
        %which is implied shorthand for
        %\verb|git checkout --track origin/dev|, which is shorthand for
        \item \verb|PyCharm|: VCS > Git > Branches, select origin/dev, Checkout as new local branch 
    \end{itemize} 
    \item Create your own feature branch. 
    \label{itm:init_laststep}
    \begin{itemize} 
        \item CL: \verb|git branch my-feature-branch| 
        \item \verb|PyCharm|: VCS > Git > Branches, New branch
    \end{itemize} 
%\end{enumerate} 
    \item \textbf{--- start here every time you work on your feature ---}
%\begin{enumerate}
    %\item Ensure there are no unstaged changes lying around.
    %\begin{itemize} 
    %    \item CL: \verb|git status|
    %    \item \verb|PyCharm|:  
    %\end{itemize} 
    %If you have made changes, \verb|git| will track them,
    %throw errors in the next steps.
    %Either commit the changes to your feature branch,
    %or get rid of them. To get rid of them:
    %\begin{itemize} 
    %    \item CL: first run \verb|git stash|, then \verb|git stash drop|
    %    \item \verb|PyCharm|:  
    %\end{itemize} 
    \item Check out the \verb|dev| branch.
    \label{itm:rebase_start}
    \begin{itemize} 
        \item CL: \verb|git checkout dev|
        \item \verb|PyCharm|: VCS > Git > Branches, dev -> origin/dev, Checkout 
    \end{itemize} 
    \item Pull the latest commits from the remote \verb|dev| branch.
    \begin{itemize} 
        \item CL: \verb|git pull origin dev|
        \item \verb|PyCharm|: VCS > Git > Pull Changes 
    \end{itemize} 
    \item Check out your feature branch.
    \begin{itemize} 
        \item CL: \verb|git checkout my-feature-branch|
        \item \verb|PyCharm|: VCS > Git > Branches, <yourFeatureBranch>, Checkout 
    \end{itemize} 
    \item Rebase your feature branch onto the \verb|dev| branch. 
    \label{itm:rebase_end}
    \begin{itemize} 
        \item CL: \verb|git rebase dev| 
        \item \verb|PyCharm|: VCS > Git > Rebase
    \end{itemize} 
    If you have conflicts during the rebase, 
    due to changes in \verb|dev| that disagree with changes in your feature,
    this step can be skipped for the moment,
    but these conflicts will eventually need to be cleaned up.
    Get help from a fellow developer, 
    or if you are pretty sure your version of the code is better,
    try a pull request!
    \item Finally, \textbf{work on your feature}. 
    \item After working, make sure you are still on your feature branch, 
    then stage your edits. 
    \begin{itemize} 
        \item CL: \verb|git add .| 
        \item \verb|PyCharm|: skip this step 
    \end{itemize} 
    \item After staging your edits, commit them with a description. 
    \label{itm:commitfeature} 
    \begin{itemize} 
        \item CL: \verb|git commit -m 'description of edits'| 
        \item \verb|PyCharm|: VCS > Commit Changes
    \end{itemize} 
    \item Push your commits on your feature branch to the origin (remote) repository.
    \label{itm:pushfeature} 
    \begin{itemize} 
        \item CL: \verb|git push origin my-feature-branch| 
        \item \verb|PyCharm|: VCS > Git > Push 
    \end{itemize} 
    Now your colleagues can see what you have done,
    and use your changes in their own code if they need to!
%\end{enumerate} 
    \item \textbf{--- start here when you are done with your feature ---}
%\begin{enumerate}
    \item Follow steps~\ref{itm:rebase_start} through~\ref{itm:rebase_end} above
    to rebase your feature branch on \verb|dev| one last time.
    %\item If the rebase changed anything, 
    %use step~\ref{itm:pushfeature} 
    %above for one last push to the remote repo.
    \item If you know that your changes 
    are not likely to crash your co-workers' codes 
    when they are merged to the \verb|dev| branch, 
    you can now merge your feature into the \verb|dev| branch
    and push \verb|dev| to the remote repository.
    \begin{itemize} 
        \item CL: 
        %\verb|git checkout dev|, 
        %then \verb|git merge my-feature-branch|, 
        %then \verb|git push origin dev|.
        \begin{lstlisting}
            git checkout dev 
            git merge my-feature-branch 
            % mildly cautious reflection 
            git push origin dev
        \end{lstlisting}
        \item \verb|PyCharm|:  
        \begin{itemize} 
            \item VCS > Git > Branches, dev -> origin/dev, Checkout 
            \item VCS > Git > Branches, <yourFeatureBranch>, Merge 
            \item mildly cautious reflection
            \item VCS > Git > Push 
        \end{itemize} 
    \end{itemize} 
    \item If you aren't 100\% sure that it's safe to merge your feature into \verb|dev|,
    submit a pull request via the online interface.
    Request to pull \verb|my-feature-branch| into \verb|dev|.
    The \verb|slacx| development team will discuss, possibly edit, 
    and ultimately accept your feature.
    \item If your feature was more appropriate for the \verb|master| branch,
    submit a pull request for the \verb|master| branch.
\end{enumerate} 

\section{developing operations for slacx}
\label{sec:op_dev}

Developing operations for use in the \verb|slacx| workflow engine 
is meant to be as painless as possible.
A continuing effort will be made to streamline this process.

The most general description of an operation 
is to treat it as a black box that takes some inputs (data and parameters),
performs some processing with those inputs,
and produces some output (data and other features).
Users can choose to build their operations in two ways.

One option is to write the function into a python class
that defines names for its inputs and outputs
and then stores the input and output data 
within objects of that class.
This process is most easily understood 
by following the template and instructions 
provided in section~\ref{sec:op_dev_by_class} below.

Another option (not yet implemented)
is to write the function into a python module 
that contains formatted metadata 
about how the function should be called,
with input and output data 
stored in the workflow engine itself.

In either case, the user/developer writes their operation 
into a module \verb|somefile.py|
and then places this module in the \verb|slacx/slacxcore/operations/| directory.
If the implementation obeys the specified format, 
the operation will automatically be made available 
to the \verb|slacx| workflow manager
the next time \verb|slacx| is started.
If the user/developer is not careful 
about implementing their operation,
\verb|slacx| may raise exceptions and exit. 
This could happen at startup (when the operation is read),
during workflow management (when the operations is loaded with inputs),
or during execution (when the operation is called upon to compute things),
depending on where (if any) errors were made.
Operations that are in development 
can be safely stored in \verb|slacx/slacxcore/operations/dmz|.

\subsection{operations as python classes}
\label{sec:op_dev_by_class}

The following code block gives a minimal, 
commented template for developing
operations as python classes.
Users/developers with some programming background
may find all the information they need in this template alone.

\lstset{language=Python}
\begin{lstlisting}
# Users and developers should remove all comments from this template.
# All text outside comments that is meant to be removed or replaced 
# is <written within angle brackets>.

# Operations implemented as python classes 
# have a common interface for communicating 
# with the slacx workflow manager.
# That common interface is ensured by inheriting it
# from an abstract class called 'Operation'.
from slacxop import Operation
import optools

# Name the operation, specify inheritance (Operation)
class <OperationName>(Operation):
    # Give a brief description of the operation
    # bracketed by """triple-double-quotes"""
    """<Description of Operation>"""

    # Write an __init__() function for the Operation.
    def __init__(self):
        # Name the input and output data/parameters for your operation.
        # Format names as 'single_quotes_without_spaces'.
        input_names = ['<input_name_1>','<input_name_2>',<...>]
        output_names = ['<output_name_1>','<output_name_2>',<...>]
        # Call the __init__ method of the Operation abstract (super)class.
        # This instantiates {key:value} dictionaries of inputs and outputs, 
        # which have keys generated from input_names and output_names.
        # All values in the dictionary are initialized as None. 
        super(Identity,self).__init__(input_names,output_names)
        # Write a free-form documentation string describing each item
        # that was named in input_names and output_names.
        self.input_doc['<input_name_1>'] = '<expectations for input 1>'
        self.input_doc['<input_name_2>'] = '<etc>'
        self.output_doc['<output_name_1>'] = '<form of output 1>'
        self.output_doc['<output_name_2>'] = '<etc>'
        # Categorize the operation. Multiple categories are acceptable.
        # Indicate subcategories with a '.' character.
        self.categories = ['<CAT1>','<CAT2>.<SUBCAT1>',<...>]
        # OPTIONAL: set default sources and types for the operation inputs.
        # This is only used for building/executing Operations in the GUI.
        # Valid sources: optools.fs_input (read input from filesystem), 
        #   optools.op_input (input from another operation's output), 
        #   optools.text_input (manual text input)
        self.input_src['<input_name_1>'] = <optools.some_source>
        self.input_src['<input_name_2>'] = <etc>
        # Valid types: optools.str_type (string), optools.int_type (integer),
        #   optools.float_type (floating-point number), optools.bool_type (boolean)
        self.input_type['<input_name_1>'] = <optools.some_type>
        self.input_type['<input_name_2>'] = <etc>
        
    # Write a run() function for this Operation.
    def run(self):
        # Optional- create references in the local namespace for cleaner code.
        <inp1> = self.inputs['<input_name_1>']
        <inp2> = self.inputs['<input_name_2>']
        <etc>
        # Perform the computation
        < ... >
        # Save the output
        self.outputs['<output_name_1>'] = <computed_value_1>
        self.outputs['<output_name_2>'] = <etc>
\end{lstlisting}


\subsection{operations as functions in a module}
\label{sec:op_dev_by_function}

This functionality is not yet implemented.

